---
layout: post
title: MRIをでバックビルドしてgdbでデバッグ
date: '2015-12-31T15:39:00.000+09:00'
author: s sato
tags:
- ruby
- C
modified_time: '2015-12-31T15:39:44.057+09:00'
blogger_id: tag:blogger.com,1999:blog-1054230703994559763.post-3471652877023009048
blogger_orig_url: http://satomemocho.blogspot.com/2015/12/mrigdb.html
---

<!DOCTYPE html><html><head><meta charset="utf-8"><title>Untitled Document.md</title><style></style></head><body id="preview"><h3><a id="MRI_1"></a>MRIのビルド</h3><p>./configure時の–enable-debug-envオプションは、コンパイラによる最適化を抑止してgdbでソースをおえるようにしてくれているはず。 システムのrubyと競合しないように–prefixでインストール先を指定する。</p><pre><code>./configure --enable-debug-env --prefix /home/sato/ruby/ CFLAGS=&quot;-g3 -O0&quot;<br />make<br />make install<br /></code></pre><h3><a id="_10"></a>環境変数を設定</h3><p>さっきインストールしたrubyの実行ファイルが呼び出されるように環境変数を設定してやる。</p><pre><code>RUBYPATH=$HOME/ruby/bin<br />export RUBYPATH<br />export PATH=$RUBYPATH:$PATH<br />export RUBYLIB=$RUBYPATH/lib/ruby<br /></code></pre><h3><a id="gdb_19"></a>gdb用のヘルパーをホームディレクトリに入れておく</h3><p>rubyの内部のデータは殆どがVALUEポインタで表現され、後でキャストしてから使用される。 この時、キャスト後が何のデータであるかがわからなければ、gdbのprintで中を覗くことができない。 このため、rubyのソースにバンドルされているgdb用のヘルパーを使う。</p><p>以下からダウンロード<br><a href="https://github.com/ruby/ruby/blob/trunk/.gdbinit">https://github.com/ruby/ruby/blob/trunk/.gdbinit</a></p><pre><code>cp .gdbinit ~/<br /></code></pre><p>定義されたヘルパーの一覧はhelp user-definedで見ることができる。</p><pre><code>(gdb) help user-defined<br />User-defined commands.<br />The commands in this class are those defined by the user.<br />Use the &quot;define&quot; command to define a command.<br /><br />List of commands:<br /><br /><br />＊＊＊＊＊＊略＊＊＊＊＊＊<br /><br />rb_p -- User-defined<br />rb_ps -- Dump all threads and their callstacks<br />rb_ps_thread -- User-defined<br />rb_ps_vm -- Dump all threads in a (rb_vm_t*) and their callstacks<br />rbi -- User-defined<br />rp --   Print a Ruby's VALUE<br />rp_class --   Print the content of a Class/Module<br />rp_id --   Print an ID<br />rp_imemo --   Print the content of a memo<br />rp_string --   Print the content of a String<br />ruby_gdb_init -- User-defined<br />sdr -- User-defined<br /></code></pre><p>重要なのはrpで、これでVALUEの中身を知ることができる。</p><h3><a id="irbgdb_60"></a>irbを起動しgdbをアタッチ</h3><pre><code>irb<br /></code></pre><p>まず、起動したirbのプロセスIDを調べる。</p><pre><code>$ ps x|grep irb<br />1742 pts/1    Sl+    0:00 irb<br /></code></pre><p>別のターミナルから起動したirbにアタッチする。</p><pre><code>gdb /home/sato/ruby/bin/irb -p 1742<br /></code></pre><h3><a id="_73"></a>ブレークポイントを設定してみる。</h3><pre><code>  (gdb) b proc_curry<br />  Breakpoint 3 at 0x7f60aa2bff64: file proc.c, line 2755.<br />  (gdb) c<br />  Continuing<br /></code></pre><p>proc_curryはProc#curryのC側での実装。 以下の関数がそれにあたる。</p><pre><code>  rb_define_method(rb_cMethod, &quot;curry&quot;, rb_method_curry, -1);<br /><br />  static VALUE<br />  proc_curry(int argc, const VALUE *argv, VALUE self)<br />  {<br />      int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);<br />      VALUE arity;<br /><br />      rb_scan_args(argc, argv, &quot;01&quot;, &amp;arity);<br />      if (NIL_P(arity)) {<br />    arity = INT2FIX(min_arity);<br />      }<br />      else {<br />    sarity = FIX2INT(arity);<br />    if (rb_proc_lambda_p(self)) {<br />        rb_check_arity(sarity, min_arity, max_arity);<br />    }<br />      }<br /><br />      return make_curry_proc(self, rb_ary_new(), arity);<br />  }<br /></code></pre><p>この状態で、irb側から以下のようにProc#curryを呼び出す</p><pre><code>  Proc.new {|x,y|x+y}.curry<br /></code></pre><p>gdbがbreakする。</p><pre><code>  Breakpoint 1, proc_curry (argc=0, argv=0x7f48ea86d258, self=139951178000880) at proc.c:2755<br />  warning: Source file is more recent than executable.<br />  2755        int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);<br /></code></pre><p>コードの中の現在位置を確認</p><pre><code>  (gdb) l<br />  2750      *     p b.curry[]                  #=&gt; :foo<br />  2751      */<br />  2752    static VALUE<br />  2753    proc_curry(int argc, const VALUE *argv, VALUE self)<br />  2754    {<br />  2755        int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);<br />  2756        VALUE arity;<br />  2757<br />  2758        rb_scan_args(argc, argv, &quot;01&quot;, &amp;arity);<br />  2759        if (NIL_P(arity)) {<br /></code></pre><p>selfのVALUEポインタを見てみる。</p><pre><code>  (gdb) rp self<br />  T_DATA(proc): $4 = (struct RTypedData *) 0x7f48ec4029f0<br />  (gdb) print *(struct RTypedData *) self<br />  $5 = {basic = {flags = 12, klass = 139951178175800}, type = 0x7f48eae51ca0 &lt;proc_data_type&gt;,<br />  typed_flag = 1, data = 0x7f48ec85bd80}<br />  (gdb) print (*(struct RTypedData *) self)-&gt;basic<br />  $6 = {flags = 12, klass = 139951178175800}<br />  (gdb) print (*(struct RTypedData *) self)-&gt;basic-&gt;klass<br />  $7 = 139951178175800<br /></code></pre> </body></html>